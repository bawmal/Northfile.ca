// Performance optimization utilities
import { useEffect, useState, useCallback, useRef } from 'react';

// Lazy loading component
export function LazyLoad({ 
  children, 
  fallback = <div>Loading...</div>,
  rootMargin = '50px'
}: { 
  children: React.ReactNode;
  fallback?: React.ReactNode;
  rootMargin?: string;
}): JSX.Element {
  const [isIntersecting, setIsIntersecting] = useState(false);
  const [hasLoaded, setHasLoaded] = useState(false);
  const elementRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const element = elementRef.current;
    if (!element) return;

    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting && !hasLoaded) {
          setIsIntersecting(true);
          setHasLoaded(true);
        }
      },
      { rootMargin }
    );

    observer.observe(element);
    return () => observer.disconnect();
  }, [rootMargin, hasLoaded]);

  return (
    <div ref={elementRef}>
      {isIntersecting ? children : fallback}
    </div>
  );
}

// Image optimization
export function OptimizedImage({
  src,
  alt,
  width,
  height,
  className = '',
  loading = 'lazy',
  sizes,
  srcSet,
}: {
  src: string;
  alt: string;
  width?: number;
  height?: number;
  className?: string;
  loading?: 'lazy' | 'eager';
  sizes?: string;
  srcSet?: string;
}) {
  const [isLoaded, setIsLoaded] = useState(false);
  const [hasError, setHasError] = useState(false);

  return (
    <div className={`relative ${className}`}>
      {!isLoaded && !hasError && (
        <div className="absolute inset-0 bg-slate-200 animate-pulse rounded" />
      )}
      <img
        src={src}
        alt={alt}
        width={width}
        height={height}
        loading={loading}
        sizes={sizes}
        srcSet={srcSet}
        className={`transition-opacity duration-300 ${
          isLoaded ? 'opacity-100' : 'opacity-0'
        } ${hasError ? 'hidden' : ''}`}
        onLoad={() => setIsLoaded(true)}
        onError={() => setHasError(true)}
      />
      {hasError && (
        <div className="absolute inset-0 flex items-center justify-center bg-slate-100 rounded">
          <span className="text-slate-500 text-sm">Failed to load image</span>
        </div>
      )}
    </div>
  );
}

// Debounce hook
export function useDebounce<T extends (...args: any[]) => any>(
  callback: T,
  delay: number
): T {
  const timeoutRef = useRef<NodeJS.Timeout>();

  return useCallback((...args: Parameters<T>) => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }

    timeoutRef.current = setTimeout(() => {
      callback(...args);
    }, delay);
  }, [callback, delay]) as T;
}

// Throttle hook
export function useThrottle<T extends (...args: any[]) => any>(
  callback: T,
  delay: number
): T {
  const lastCallRef = useRef<number>(0);

  return useCallback((...args: Parameters<T>) => {
    const now = Date.now();
    if (now - lastCallRef.current >= delay) {
      lastCallRef.current = now;
      callback(...args);
    }
  }, [callback, delay]) as T;
}

// Virtual scrolling for large lists
export function VirtualList({
  items,
  itemHeight,
  containerHeight,
  renderItem,
  className = '',
}: {
  items: any[];
  itemHeight: number;
  containerHeight: number;
  renderItem: (item: any, index: number) => React.ReactNode;
  className?: string;
}) {
  const [scrollTop, setScrollTop] = useState(0);
  
  const visibleStart = Math.floor(scrollTop / itemHeight);
  const visibleEnd = Math.min(
    visibleStart + Math.ceil(containerHeight / itemHeight) + 1,
    items.length
  );
  
  const visibleItems = items.slice(visibleStart, visibleEnd);
  const totalHeight = items.length * itemHeight;
  
  return (
    <div 
      className={`overflow-auto ${className}`}
      style={{ height: containerHeight }}
      onScroll={(e) => setScrollTop(e.currentTarget.scrollTop)}
    >
      <div style={{ height: totalHeight, position: 'relative' }}>
        <div 
          style={{ 
            transform: `translateY(${visibleStart * itemHeight}px)`,
            position: 'absolute',
            top: 0,
            left: 0,
            right: 0
          }}
        >
          {visibleItems.map((item, index) => 
            renderItem(item, visibleStart + index)
          )}
        </div>
      </div>
    </div>
  );
}

// Performance monitoring
export class PerformanceMonitor {
  private static metrics = new Map<string, number[]>();
  
  static startTimer(name: string): () => void {
    const startTime = performance.now();
    
    return () => {
      const endTime = performance.now();
      const duration = endTime - startTime;
      
      if (!this.metrics.has(name)) {
        this.metrics.set(name, []);
      }
      
      this.metrics.get(name)!.push(duration);
      
      // Keep only last 100 measurements
      const measurements = this.metrics.get(name)!;
      if (measurements.length > 100) {
        measurements.shift();
      }
      
      // Log slow operations
      if (duration > 100) {
        console.warn(`Slow operation: ${name} took ${duration.toFixed(2)}ms`);
      }
    };
  }
  
  static getMetrics(name: string): {
    average: number;
    min: number;
    max: number;
    count: number;
  } | null {
    const measurements = this.metrics.get(name);
    if (!measurements || measurements.length === 0) return null;
    
    const sum = measurements.reduce((a, b) => a + b, 0);
    const average = sum / measurements.length;
    const min = Math.min(...measurements);
    const max = Math.max(...measurements);
    
    return { average, min, max, count: measurements.length };
  }
  
  static getAllMetrics(): Record<string, {
    average: number;
    min: number;
    max: number;
    count: number;
  }> {
    const result: Record<string, any> = {};
    
    for (const [name] of this.metrics.entries()) {
      result[name] = this.getMetrics(name);
    }
    
    return result;
  }
}

// Resource optimization
export function preloadImage(src: string): Promise<void> {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => resolve();
    img.onerror = () => reject(new Error(`Failed to preload image: ${src}`));
    img.src = src;
  });
}

export function preloadResources(resources: string[]): Promise<void[]> {
  return Promise.all(resources.map(resource => preloadImage(resource)));
}

// Memory management
export class MemoryManager {
  private static cache = new Map<string, { data: any; timestamp: number; ttl: number }>();
  
  static set(key: string, data: any, ttl: number = 5 * 60 * 1000): void {
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      ttl
    });
  }
  
  static get<T = any>(key: string): T | null {
    const item = this.cache.get(key);
    if (!item) return null;
    
    if (Date.now() - item.timestamp > item.ttl) {
      this.cache.delete(key);
      return null;
    }
    
    return item.data;
  }
  
  static delete(key: string): void {
    this.cache.delete(key);
  }
  
  static clear(): void {
    this.cache.clear();
  }
  
  static cleanup(): void {
    const now = Date.now();
    
    for (const [key, item] of this.cache.entries()) {
      if (now - item.timestamp > item.ttl) {
        this.cache.delete(key);
      }
    }
  }
  
  static getStats(): { size: number; memoryUsage: number } {
    return {
      size: this.cache.size,
      memoryUsage: JSON.stringify([...this.cache.entries()]).length
    };
  }
}

// Bundle size optimization
export function dynamicImport<T = any>(
  importFunction: () => Promise<T>
): Promise<T> {
  return importFunction();
}

// Route-based code splitting
export const lazyLoad = {
  // Properties
  properties: () => dynamicImport(() => import('@/app/(dashboard)/properties/page')),
  propertiesAdd: () => dynamicImport(() => import('@/app/(dashboard)/properties/add')),
  
  // Transactions
  transactions: () => dynamicImport(() => import('@/app/(dashboard)/transactions/page')),
  
  // Reports
  reports: () => dynamicImport(() => import('@/app/(dashboard)/reports/page')),
  t776: () => dynamicImport(() => import('@/app/(dashboard)/reports/t776/page')),
  
  // Other pages
  receipts: () => dynamicImport(() => import('@/app/(dashboard)/receipts/page')),
  mortgages: () => dynamicImport(() => import('@/app/(dashboard)/mortgages/page')),
  notices: () => dynamicImport(() => import('@/app/(dashboard)/notices/page')),
  collaboration: () => dynamicImport(() => import('@/app/(dashboard)/collaboration/page')),
};

// Performance hooks
export function usePerformanceMonitor(operationName: string) {
  const startTimeRef = useRef<number>();
  
  const start = useCallback(() => {
    startTimeRef.current = performance.now();
  }, []);
  
  const end = useCallback(() => {
    if (startTimeRef.current) {
      const duration = performance.now() - startTimeRef.current;
      PerformanceMonitor.startTimer(operationName)();
      console.log(`${operationName} completed in ${duration.toFixed(2)}ms`);
    }
  }, [operationName]);
  
  return { start, end };
}

// Cleanup interval for memory management
if (typeof window === 'undefined') {
  setInterval(() => {
    MemoryManager.cleanup();
  }, 60 * 1000); // Cleanup every minute
}
